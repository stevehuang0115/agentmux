import * as path from 'path';
import { readFile } from 'fs/promises';
import { LoggerService, ComponentLogger } from '../core/logger.service.js';
import { TmuxCommandService } from './tmux-command.service.js';
import { RuntimeAgentService } from './runtime-agent.service.abstract.js';
import { RuntimeServiceFactory } from './runtime-service.factory.js';
import { StorageService } from '../core/storage.service.js';
import {
	AGENTMUX_CONSTANTS,
	ENV_CONSTANTS,
	AGENT_TIMEOUTS,
	ORCHESTRATOR_ROLE,
	RUNTIME_TYPES,
	RuntimeType,
} from '../../constants.js';

export interface OrchestratorConfig {
	sessionName: string;
	projectPath: string;
	windowName?: string;
}

/**
 * Service responsible for the complex, multi-step process of agent initialization and registration.
 * Isolates the complex state management of agent startup with progressive escalation.
 */
export class AgentRegistrationService {
	private logger: ComponentLogger;
	private tmuxCommand: TmuxCommandService;
	private storageService: StorageService;
	private projectRoot: string;

	// Prompt file caching to eliminate file I/O contention during concurrent session creation
	private promptCache = new Map<string, string>();

	constructor(
		tmuxCommandService: TmuxCommandService,
		projectRoot: string | null,
		storageService: StorageService
	) {
		this.logger = LoggerService.getInstance().createComponentLogger('AgentRegistrationService');
		this.tmuxCommand = tmuxCommandService;
		this.storageService = storageService;
		this.projectRoot = projectRoot || this.findProjectRoot();
	}

	/**
	 * Find the project root by looking for package.json
	 */
	private findProjectRoot(): string {
		// Simple fallback - could be improved to walk up directories
		return process.cwd();
	}

	/**
	 * Initialize agent with optimized 2-step escalation process
	 * Reduced from 4-step to 2-step with shorter timeouts for better concurrency
	 */
	async initializeAgentWithRegistration(
		sessionName: string,
		role: string,
		projectPath?: string,
		timeout: number = AGENT_TIMEOUTS.REGULAR_AGENT_INITIALIZATION,
		memberId?: string,
		runtimeType: RuntimeType = RUNTIME_TYPES.CLAUDE_CODE
	): Promise<{
		success: boolean;
		message?: string;
		error?: string;
	}> {
		const startTime = Date.now();

		this.logger.info('Starting optimized agent initialization with registration', {
			sessionName,
			role,
			timeout,
			runtimeType,
		});

		// Set agent status to "activating" when starting initialization
		try {
			await this.storageService.updateAgentStatus(
				sessionName,
				AGENTMUX_CONSTANTS.AGENT_STATUSES.ACTIVATING
			);
			this.logger.info('Set agent status to activating', { sessionName, role });
		} catch (error) {
			this.logger.warn('Failed to set agent status to activating', {
				sessionName,
				role,
				error: error instanceof Error ? error.message : String(error),
			});
		}

		// Clear detection cache to ensure fresh runtime detection  
		const runtimeService = RuntimeServiceFactory.create(runtimeType, this.tmuxCommand, this.projectRoot);
		runtimeService.clearDetectionCache(sessionName);

		// Skip Step 1 (direct registration) as it often fails in concurrent scenarios
		// Go directly to Step 2: Cleanup + reinit (more reliable)
		try {
			this.logger.info('Step 1: Attempting cleanup and reinitialization', {
				sessionName,
			});
			const step1Success = await this.tryCleanupAndReinit(
				sessionName,
				role,
				40000, // 40 seconds for cleanup and reinit
				projectPath,
				memberId,
				runtimeType
			);
			if (step1Success) {
				return {
					success: true,
					message: 'Agent registered successfully after cleanup and reinit',
				};
			}
		} catch (error) {
			this.logger.warn('Step 1 (cleanup + reinit) failed', {
				sessionName,
				error: error instanceof Error ? error.message : String(error),
			});
		}

		// Step 2: Full session recreation (30 seconds) - only if time remaining
		if (Date.now() - startTime < timeout - 35000) {
			try {
				this.logger.info('Step 2: Attempting full session recreation', { sessionName });
				const step2Success = await this.tryFullRecreation(
					sessionName,
					role,
					30000, // Reduced from 45000 to 30000
					projectPath,
					memberId,
					runtimeType
				);
				if (step2Success) {
					return {
						success: true,
						message: 'Agent registered successfully after full recreation',
					};
				}
			} catch (error) {
				this.logger.warn('Step 2 (full recreation) failed', {
					sessionName,
					error: error instanceof Error ? error.message : String(error),
				});
			}
		}

		// Give up after 2 steps
		const errorMsg = `Failed to initialize agent after optimized escalation attempts (${Math.round(
			(Date.now() - startTime) / 1000
		)}s)`;
		this.logger.error(errorMsg, { sessionName, role });
		return { success: false, error: errorMsg };
	}

	/**
	 * Step 1: Try direct registration prompt
	 * Assumes Claude is already running and just needs a registration prompt
	 */
	private async tryDirectRegistration(
		sessionName: string,
		role: string,
		timeout: number,
		memberId?: string,
		runtimeType: RuntimeType = RUNTIME_TYPES.CLAUDE_CODE
	): Promise<boolean> {
		// First clear any existing stuff
		await this.tmuxCommand.sendCtrlC(sessionName);

		// First check if runtime is running before sending the prompt
		const runtimeService2 = RuntimeServiceFactory.create(runtimeType, this.tmuxCommand, this.projectRoot);
		const runtimeRunning = await runtimeService2.detectRuntimeWithCommand(sessionName);
		if (!runtimeRunning) {
			this.logger.debug('Runtime not detected in Step 1, skipping direct registration', {
				sessionName,
				runtimeType,
			});
			return false;
		}

		this.logger.debug('Runtime detected, sending registration prompt', { sessionName, runtimeType });

		// Send Ctrl+C to cancel any pending slash command from detection
		await this.tmuxCommand.sendCtrlC(sessionName);

		const prompt = await this.loadRegistrationPrompt(role, sessionName, memberId);
		const promptDelivered = await this.sendPromptRobustly(sessionName, prompt);

		if (!promptDelivered) {
			this.logger.warn('Failed to deliver registration prompt', { sessionName, role });
			return false;
		}

		return await this.waitForRegistration(sessionName, role, timeout);
	}

	/**
	 * Step 2: Cleanup with Ctrl+C and reinitialize
	 * Tries to reset the runtime session and start fresh
	 */
	private async tryCleanupAndReinit(
		sessionName: string,
		role: string,
		timeout: number,
		projectPath?: string,
		memberId?: string,
		runtimeType: RuntimeType = RUNTIME_TYPES.CLAUDE_CODE
	): Promise<boolean> {
		// Send Escape & Ctrl+C signals
		await this.tmuxCommand.sendEscape(sessionName);
		await this.tmuxCommand.sendCtrlC(sessionName);

		// Wait a moment for cleanup
		await new Promise((resolve) => setTimeout(resolve, 2000));

		// Reinitialize runtime using the appropriate initialization script
		const runtimeService2 = RuntimeServiceFactory.create(runtimeType, this.tmuxCommand, this.projectRoot);
		await runtimeService2.executeRuntimeInitScript(sessionName, projectPath);

		// Wait for runtime to be ready (enhanced detection)
		// Use shorter grace period in test environment
		const gracePeriod = process.env.NODE_ENV === 'test' ? 0 : 60000;
		const isReady = await runtimeService2.waitForRuntimeReady(sessionName, 30000, gracePeriod); // Reduced timeout
		if (!isReady) {
			throw new Error(`Failed to reinitialize ${runtimeType} within timeout`);
		}

		// Fast verification and registration with retry (skip Ctrl+C since runtime was just initialized)
		return await this.attemptRegistrationWithVerification(
			sessionName,
			role,
			timeout,
			memberId,
			3,
			true,
			runtimeType
		);
	}

	/**
	 * Step 3: Kill session and recreate completely
	 * Most aggressive approach - completely recreates the session from scratch
	 */
	private async tryFullRecreation(
		sessionName: string,
		role: string,
		timeout: number,
		projectPath?: string,
		memberId?: string,
		runtimeType: RuntimeType = RUNTIME_TYPES.CLAUDE_CODE
	): Promise<boolean> {
		// Kill existing session
		await this.tmuxCommand.killSession(sessionName);

		// Wait for cleanup
		await new Promise((resolve) => setTimeout(resolve, 1000));

		// Recreate session based on role
		if (role === ORCHESTRATOR_ROLE) {
			await this.createOrchestratorSession({
				sessionName,
				projectPath: projectPath || process.cwd(),
			});

			// Initialize runtime for orchestrator using script (stay in agentmux project)
			const runtimeService = RuntimeServiceFactory.create(runtimeType, this.tmuxCommand, this.projectRoot);
		await runtimeService.executeRuntimeInitScript(sessionName, process.cwd());

			// Wait for runtime to be ready
			// Use shorter grace period in test environment
			const gracePeriod = process.env.NODE_ENV === 'test' ? 0 : 60000;
			const runtimeService3 = RuntimeServiceFactory.create(runtimeType, this.tmuxCommand, this.projectRoot);
			const isReady = await runtimeService3.waitForRuntimeReady(
				sessionName,
				45000,
				gracePeriod
			);
			if (!isReady) {
				throw new Error(
					`Failed to initialize ${runtimeType} in recreated orchestrator session within timeout`
				);
			}

			// Additional verification: Use runtime detection to confirm runtime is responding
			// Wait a bit longer for runtime to fully load after showing welcome message
			this.logger.debug(
				'Runtime ready detected for orchestrator, waiting for full startup before verification',
				{ sessionName, runtimeType }
			);
			await new Promise((resolve) => setTimeout(resolve, 5000));

			this.logger.debug('Verifying orchestrator runtime responsiveness', {
				sessionName,
				runtimeType,
			});
			const runtimeService4 = RuntimeServiceFactory.create(runtimeType, this.tmuxCommand, this.projectRoot);
			const runtimeResponding = await runtimeService4.detectRuntimeWithCommand(
				sessionName
			);
			if (!runtimeResponding) {
				throw new Error(`${runtimeType} not responding to commands after orchestrator recreation`);
			}

			this.logger.debug(
				'Runtime confirmed ready for orchestrator in Step 3, sending registration prompt',
				{ sessionName, runtimeType }
			);

			// Send Ctrl+C to cancel any pending slash command from detection
			await this.tmuxCommand.sendCtrlC(sessionName);
		} else {
			// For other roles, create basic session and initialize Claude
			await this.tmuxCommand.createSession(sessionName, projectPath || process.cwd());

			// Initialize runtime using the initialization script
			const runtimeService = RuntimeServiceFactory.create(runtimeType, this.tmuxCommand, this.projectRoot);
		await runtimeService.executeRuntimeInitScript(sessionName, projectPath);

			// Wait for runtime to be ready (enhanced detection)
			// Use shorter grace period in test environment
			const gracePeriod = process.env.NODE_ENV === 'test' ? 0 : 60000;
			const isReady = await RuntimeServiceFactory.create(runtimeType, this.tmuxCommand, this.projectRoot).waitForRuntimeReady(
				sessionName,
				25000,
				gracePeriod
			); // Reduced timeout
			if (!isReady) {
				throw new Error(`Failed to initialize ${runtimeType} in recreated session within timeout`);
			}
		}

		// Use enhanced registration with verification (skip Ctrl+C since runtime was just initialized)
		return await this.attemptRegistrationWithVerification(
			sessionName,
			role,
			timeout,
			memberId,
			3,
			true,
			runtimeType
		);
	}

	/**
	 * Load registration prompt from config files (with caching to prevent file I/O contention)
	 */
	private async loadRegistrationPrompt(
		role: string,
		sessionName: string,
		memberId?: string
	): Promise<string> {
		try {
			// Create cache key based on role and whether memberId is used
			const cacheKey = `${role}-${!!memberId}`;

			// Check cache first to avoid file I/O during concurrent operations
			if (!this.promptCache.has(cacheKey)) {
				this.logger.debug('Loading prompt template from file', { role, cacheKey });
				const promptPath = path.join(
					process.cwd(),
					'config',
					'prompts',
					`${role}-prompt.md`
				);
				const promptTemplate = await readFile(promptPath, 'utf8');
				this.promptCache.set(cacheKey, promptTemplate);
				this.logger.debug('Prompt template cached', { role, cacheKey });
			} else {
				this.logger.debug('Using cached prompt template', { role, cacheKey });
			}

			// Get cached template and apply variable replacements
			let prompt = this.promptCache.get(cacheKey)!;

			// Replace session ID and member ID placeholders
			prompt = prompt.replace(/\{\{SESSION_ID\}\}/g, sessionName);
			if (memberId) {
				prompt = prompt.replace(/\{\{MEMBER_ID\}\}/g, memberId);
			} else {
				// For orchestrator or cases without member ID, remove the memberId parameter
				prompt = prompt.replace(/,\s*"memberId":\s*"\{\{MEMBER_ID\}\}"/g, '');
			}

			return prompt;
		} catch (error) {
			// Fallback to inline prompt if file doesn't exist
			this.logger.warn('Could not load prompt from config, using fallback', {
				role,
				error: error instanceof Error ? error.message : String(error),
			});

			return `Please immediately run: register_agent_status with parameters {"role": "${role}", "sessionId": "${sessionName}"}`;
		}
	}

	/**
	 * Wait for agent registration to complete
	 */
	private async waitForRegistration(
		sessionName: string,
		role: string,
		timeout: number
	): Promise<boolean> {
		const startTime = Date.now();
		const checkInterval = 5000; // Check every 5 seconds to prevent overlapping with `/` detection

		while (Date.now() - startTime < timeout) {
			try {
				if (await this.checkAgentRegistration(sessionName, role)) {
					this.logger.info('Agent registration confirmed', { sessionName, role });
					return true;
				}

				await new Promise((resolve) => setTimeout(resolve, checkInterval));
			} catch (error) {
				this.logger.warn('Error checking registration', {
					sessionName,
					role,
					error: error instanceof Error ? error.message : String(error),
				});
				await new Promise((resolve) => setTimeout(resolve, checkInterval));
			}
		}

		this.logger.warn('Timeout waiting for agent registration', { sessionName, role, timeout });
		return false;
	}

	/**
	 * Check if agent is properly registered
	 */
	private async checkAgentRegistration(sessionName: string, role: string): Promise<boolean> {
		try {
			if (role === ORCHESTRATOR_ROLE) {
				// For orchestrator, check agentStatus is active
				const orchestratorStatus = await this.storageService.getOrchestratorStatus();
				return orchestratorStatus?.agentStatus === AGENTMUX_CONSTANTS.AGENT_STATUSES.ACTIVE;
			}

			// For team members, check teams data
			const teams = await this.storageService.getTeams();

			// Find team member with matching sessionName and check agentStatus
			for (const team of teams) {
				if (team.members) {
					for (const member of team.members) {
						if (member.sessionName === sessionName && member.role === role) {
							return member.agentStatus === AGENTMUX_CONSTANTS.AGENT_STATUSES.ACTIVE;
						}
					}
				}
			}

			return false;
		} catch (error) {
			this.logger.debug('Error checking agent registration', {
				sessionName,
				role,
				error: error instanceof Error ? error.message : String(error),
			});
			return false;
		}
	}

	/**
	 * Fast registration with verification and retry mechanism
	 * Sends system prompt to runtime which triggers MCP registration via teams.json
	 * @param skipInitialCleanup If true, skips Ctrl+C on first attempt (when runtime was just initialized)
	 */
	private async attemptRegistrationWithVerification(
		sessionName: string,
		role: string,
		timeout: number,
		memberId?: string,
		maxRetries: number = 3,
		skipInitialCleanup: boolean = false,
		runtimeType: RuntimeType = RUNTIME_TYPES.CLAUDE_CODE
	): Promise<boolean> {
		for (let attempt = 1; attempt <= maxRetries; attempt++) {
			this.logger.info('Attempting system prompt registration with MCP flow', {
				sessionName,
				role,
				runtimeType,
				attempt,
				maxRetries,
			});

			try {
				// Step 1: Send Ctrl+C to clear any pending commands (skip on first attempt if Claude was just initialized)
				if (!skipInitialCleanup || attempt > 1) {
					await this.tmuxCommand.sendCtrlC(sessionName);
					await new Promise((resolve) => setTimeout(resolve, 500));
					this.logger.debug('Sent Ctrl+C to clear terminal state', {
						sessionName,
						attempt,
					});
				} else {
					this.logger.debug(
						'Skipping Ctrl+C on first attempt (Claude was just initialized)',
						{ sessionName, attempt }
					);
				}

				// Step 2: Verify runtime is running (skip detection if runtime was just initialized and verified)
				let runtimeRunning = true; // Assume true if we skip detection

				if (!skipInitialCleanup || attempt > 1) {
					// Only do runtime detection on retries or when runtime wasn't just initialized
					const forceRefresh = attempt > 1; // Force refresh on retry attempts
					const runtimeService5 = RuntimeServiceFactory.create(runtimeType, this.tmuxCommand, this.projectRoot);
					runtimeRunning = await runtimeService5.detectRuntimeWithCommand(
						sessionName,
						forceRefresh
					);

					if (!runtimeRunning) {
						this.logger.warn('Runtime not detected, cannot send system prompt', {
							sessionName,
							runtimeType,
							attempt,
							forceRefresh,
						});

						// Clear detection cache before continuing to retry
						const runtimeService6 = RuntimeServiceFactory.create(runtimeType, this.tmuxCommand, this.projectRoot);
						runtimeService6.clearDetectionCache(sessionName);

						// Add longer delay between failed detection attempts
						if (attempt < maxRetries) {
							await new Promise((resolve) => setTimeout(resolve, 2000));
						}
						continue; // Try again
					}
				} else {
					this.logger.debug(
						'Skipping runtime detection (runtime was just initialized and verified)',
						{
							sessionName,
							runtimeType,
							attempt,
						}
					);
				}

				// Step 3: Send system prompt with robust delivery mechanism
				const prompt = await this.loadRegistrationPrompt(role, sessionName, memberId);
				const promptDelivered = await this.sendPromptRobustly(sessionName, prompt);

				if (!promptDelivered) {
					this.logger.warn('Failed to deliver system prompt reliably', {
						sessionName,
						attempt,
						promptLength: prompt.length,
					});
					continue; // Try again
				}

				this.logger.debug('System prompt delivered successfully', {
					sessionName,
					promptLength: prompt.length,
				});

				this.logger.debug('Terminal activity detected, waiting for MCP registration', {
					sessionName,
				});

				// Step 5: Wait for MCP tool call to update teams.json (agentStatus: activating -> active)
				const registrationTimeout = Math.min(timeout, 25000); // Max 25s per attempt
				const registered = await this.waitForRegistrationFast(
					sessionName,
					role,
					registrationTimeout
				);

				if (registered) {
					this.logger.info('MCP registration successful (teams.json updated)', {
						sessionName,
						role,
						attempt,
					});
					return true;
				}

				this.logger.warn('MCP registration timeout, retrying', {
					sessionName,
					role,
					attempt,
					nextAttempt: attempt < maxRetries,
				});
			} catch (error) {
				this.logger.error('System prompt registration attempt failed', {
					sessionName,
					role,
					attempt,
					error: error instanceof Error ? error.message : String(error),
				});
			}

			// Short delay before retry
			if (attempt < maxRetries) {
				await new Promise((resolve) => setTimeout(resolve, 1000));
			}
		}

		this.logger.error('All runtime registration attempts failed', {
			sessionName,
			role,
			runtimeType,
			maxRetries,
		});
		return false;
	}

	/**
	 * Fast registration polling with shorter intervals
	 */
	private async waitForRegistrationFast(
		sessionName: string,
		role: string,
		timeout: number
	): Promise<boolean> {
		const startTime = Date.now();
		const fastCheckInterval = 2000; // Check every 2 seconds (faster than original 5s)

		while (Date.now() - startTime < timeout) {
			try {
				if (await this.checkAgentRegistration(sessionName, role)) {
					this.logger.info('Fast registration confirmation', { sessionName, role });
					return true;
				}

				await new Promise((resolve) => setTimeout(resolve, fastCheckInterval));
			} catch (error) {
				this.logger.debug('Error in fast registration check', {
					sessionName,
					role,
					error: error instanceof Error ? error.message : String(error),
				});
				await new Promise((resolve) => setTimeout(resolve, 1000)); // Shorter error delay
			}
		}

		this.logger.warn('Fast registration timeout', { sessionName, role, timeout });
		return false;
	}

	/**
	 * Create orchestrator session - extracted from the original tmux service
	 */
	private async createOrchestratorSession(config: OrchestratorConfig): Promise<void> {
		this.logger.info('Creating orchestrator session', {
			sessionName: config.sessionName,
			projectPath: config.projectPath,
		});

		// Check if session already exists
		if (await this.tmuxCommand.sessionExists(config.sessionName)) {
			this.logger.info('Orchestrator session already exists', {
				sessionName: config.sessionName,
			});
			return;
		}

		// Create new tmux session for orchestrator
		await this.tmuxCommand.createSession(
			config.sessionName,
			config.projectPath,
			config.windowName
		);

		this.logger.info('Orchestrator session created successfully', {
			sessionName: config.sessionName,
		});
	}

	/**
	 * Unified session creation that handles both orchestrator and team members
	 * @param config Session configuration
	 * @returns Promise with success/error information
	 */
	async createAgentSession(config: {
		sessionName: string;
		role: string;
		projectPath?: string;
		windowName?: string;
		memberId?: string;
		runtimeType?: RuntimeType;
	}): Promise<{
		success: boolean;
		sessionName?: string;
		message?: string;
		error?: string;
	}> {
		const { sessionName, role, projectPath = process.cwd(), windowName, memberId } = config;
		
		// Get runtime type from config or default to claude-code
		let runtimeType = config.runtimeType || RUNTIME_TYPES.CLAUDE_CODE;
		
		// For team members, try to get runtime type from storage
		if (!config.runtimeType && role !== ORCHESTRATOR_ROLE) {
			try {
				const teams = await this.storageService.getTeams();
				for (const team of teams) {
					const member = team.members?.find(m => m.sessionName === sessionName);
					if (member && member.runtimeType) {
						runtimeType = member.runtimeType as RuntimeType;
						break;
					}
				}
			} catch (error) {
				this.logger.warn('Failed to get runtime type from storage, using default', {
					sessionName,
					role,
					error: error instanceof Error ? error.message : String(error),
				});
			}
		}
		
		// For orchestrator, try to get runtime type from orchestrator status
		if (role === ORCHESTRATOR_ROLE && !config.runtimeType) {
			try {
				const orchestratorStatus = await this.storageService.getOrchestratorStatus();
				if (orchestratorStatus?.runtimeType) {
					runtimeType = orchestratorStatus.runtimeType as RuntimeType;
				}
			} catch (error) {
				this.logger.warn('Failed to get orchestrator runtime type from storage, using default', {
					sessionName,
					role,
					error: error instanceof Error ? error.message : String(error),
				});
			}
		}

		try {
			this.logger.info('Creating agent session (unified approach)', { sessionName, role, runtimeType });

			// Check if session already exists
			if (await this.tmuxCommand.sessionExists(sessionName)) {
				this.logger.info('Session already exists, killing for clean restart', {
					sessionName,
				});
				await this.tmuxCommand.killSession(sessionName);
				await new Promise((resolve) => setTimeout(resolve, 1000)); // Wait for cleanup
			}

			// Create new tmux session (same approach for both orchestrator and team members)
			await this.tmuxCommand.createSession(sessionName, projectPath, windowName);

			// Set environment variables for MCP connection
			await this.tmuxCommand.setEnvironmentVariable(
				sessionName,
				ENV_CONSTANTS.TMUX_SESSION_NAME,
				sessionName
			);
			await this.tmuxCommand.setEnvironmentVariable(
				sessionName,
				ENV_CONSTANTS.AGENTMUX_ROLE,
				role
			);

			this.logger.info('Agent session created, initializing with registration', {
				sessionName,
				role,
				runtimeType,
			});

			// Use the existing unified registration system
			const timeout =
				role === ORCHESTRATOR_ROLE
					? AGENT_TIMEOUTS.ORCHESTRATOR_INITIALIZATION
					: AGENT_TIMEOUTS.REGULAR_AGENT_INITIALIZATION;
			const initResult = await this.initializeAgentWithRegistration(
				sessionName,
				role,
				projectPath,
				timeout,
				memberId,
				runtimeType
			);

			if (!initResult.success) {
				return {
					success: false,
					sessionName,
					error: initResult.error || 'Failed to initialize and register agent',
				};
			}

			return {
				success: true,
				sessionName,
				message: initResult.message || 'Agent session created and registered successfully',
			};
		} catch (error) {
			const errorMessage = error instanceof Error ? error.message : String(error);
			this.logger.error('Failed to create agent session', {
				sessionName,
				role,
				error: errorMessage,
			});

			return {
				success: false,
				sessionName,
				error: errorMessage,
			};
		}
	}

	/**
	 * Unified session termination that handles both orchestrator and team members
	 * @param sessionName The session to terminate
	 * @param role The role for proper status updates
	 * @returns Promise with success/error information
	 */
	async terminateAgentSession(
		sessionName: string,
		role: string = 'unknown'
	): Promise<{
		success: boolean;
		message?: string;
		error?: string;
	}> {
		try {
			this.logger.info('Terminating agent session (unified approach)', { sessionName, role });

			const sessionExists = await this.tmuxCommand.sessionExists(sessionName);

			if (sessionExists) {
				// Kill the tmux session
				await this.tmuxCommand.killSession(sessionName);
				this.logger.info('Session terminated successfully', { sessionName });
			} else {
				this.logger.info('Session already terminated or does not exist', { sessionName });
			}

			// Update agent status to inactive (works for both orchestrator and team members)
			await this.storageService.updateAgentStatus(
				sessionName,
				AGENTMUX_CONSTANTS.AGENT_STATUSES.INACTIVE
			);
			this.logger.info('Agent status updated to inactive', { sessionName, role });

			return {
				success: true,
				message: sessionExists
					? 'Agent session terminated successfully'
					: 'Agent session was already terminated',
			};
		} catch (error) {
			const errorMessage = error instanceof Error ? error.message : String(error);
			this.logger.error('Failed to terminate agent session', {
				sessionName,
				role,
				error: errorMessage,
			});

			return {
				success: false,
				error: errorMessage,
			};
		}
	}

	/**
	 * Generic message sending to any agent session
	 * @param sessionName The agent session name
	 * @param message The message to send
	 * @returns Promise with success/error information
	 */
	async sendMessageToAgent(
		sessionName: string,
		message: string
	): Promise<{
		success: boolean;
		message?: string;
		error?: string;
	}> {
		try {
			if (!message || typeof message !== 'string') {
				return {
					success: false,
					error: 'Message is required and must be a string',
				};
			}

			// Check if session exists
			const sessionExists = await this.tmuxCommand.sessionExists(sessionName);
			if (!sessionExists) {
				return {
					success: false,
					error: `Session '${sessionName}' does not exist`,
				};
			}

			// Send message using tmux command service
			await this.tmuxCommand.sendMessage(sessionName, message);

			this.logger.info('Message sent to agent successfully', {
				sessionName,
				messageLength: message.length,
			});

			return {
				success: true,
				message: 'Message sent to agent successfully',
			};
		} catch (error) {
			const errorMessage = error instanceof Error ? error.message : String(error);
			this.logger.error('Failed to send message to agent', {
				sessionName,
				error: errorMessage,
			});

			return {
				success: false,
				error: errorMessage,
			};
		}
	}

	/**
	 * Generic key sending to any agent session
	 * @param sessionName The agent session name
	 * @param key The key to send (e.g., 'Enter', 'Ctrl+C')
	 * @returns Promise with success/error information
	 */
	async sendKeyToAgent(
		sessionName: string,
		key: string
	): Promise<{
		success: boolean;
		message?: string;
		error?: string;
	}> {
		try {
			// Check if session exists
			const sessionExists = await this.tmuxCommand.sessionExists(sessionName);
			if (!sessionExists) {
				return {
					success: false,
					error: `Session '${sessionName}' does not exist`,
				};
			}

			// Send key using tmux command service
			await this.tmuxCommand.sendKey(sessionName, key);

			this.logger.info('Key sent to agent successfully', {
				sessionName,
				key,
			});

			return {
				success: true,
				message: `${key} key sent to agent successfully`,
			};
		} catch (error) {
			const errorMessage = error instanceof Error ? error.message : String(error);
			this.logger.error('Failed to send key to agent', {
				sessionName,
				key,
				error: errorMessage,
			});

			return {
				success: false,
				error: errorMessage,
			};
		}
	}

	/**
	 * Generic health check for any agent session
	 * @param sessionName The agent session name
	 * @param role The agent role for additional context
	 * @param timeout Timeout for health check in milliseconds
	 * @returns Promise with health status information
	 */
	async checkAgentHealth(
		sessionName: string,
		role?: string,
		timeout: number = 1000
	): Promise<{
		success: boolean;
		data?: {
			agent: {
				sessionName: string;
				role?: string;
				running: boolean;
				status: (typeof AGENTMUX_CONSTANTS.AGENT_STATUSES)[keyof typeof AGENTMUX_CONSTANTS.AGENT_STATUSES];
			};
			timestamp: string;
		};
		error?: string;
	}> {
		try {
			// Lightweight health check with timeout
			const agentRunning = await Promise.race([
				this.tmuxCommand.sessionExists(sessionName),
				new Promise<boolean>((_, reject) =>
					setTimeout(() => reject(new Error('Health check timeout')), timeout)
				),
			]).catch(() => false);

			return {
				success: true,
				data: {
					agent: {
						sessionName,
						role,
						running: agentRunning,
						status: agentRunning
							? AGENTMUX_CONSTANTS.AGENT_STATUSES.ACTIVE
							: AGENTMUX_CONSTANTS.AGENT_STATUSES.INACTIVE,
					},
					timestamp: new Date().toISOString(),
				},
			};
		} catch (error) {
			const errorMessage = error instanceof Error ? error.message : String(error);
			this.logger.error('Failed to check agent health', {
				sessionName,
				role,
				error: errorMessage,
			});

			return {
				success: false,
				error: errorMessage,
			};
		}
	}

	/**
	 * Send system prompt with robust delivery mechanism to handle tmux race conditions
	 * @param sessionName The tmux session name
	 * @param prompt The system prompt to send
	 * @returns true if prompt was delivered successfully, false otherwise
	 */
	private async sendPromptRobustly(sessionName: string, prompt: string): Promise<boolean> {
		const maxAttempts = 3;

		for (let attempt = 1; attempt <= maxAttempts; attempt++) {
			try {
				this.logger.debug('Attempting robust prompt delivery', {
					sessionName,
					attempt,
					promptLength: prompt.length,
				});

				// Capture state before sending
				const beforeOutput = await this.tmuxCommand.capturePane(sessionName, 10);
				const beforeLength = beforeOutput.length;

				// Send the prompt with proper timing
				await this.tmuxCommand.sendMessage(sessionName, prompt);

				// Critical delay to prevent tmux race condition
				await new Promise((resolve) => setTimeout(resolve, 500));

				// Send Enter key
				await this.tmuxCommand.sendEnter(sessionName);

				// Wait for processing to begin
				await new Promise((resolve) => setTimeout(resolve, 2000));

				// Verify prompt was delivered and processed
				const afterOutput = await this.tmuxCommand.capturePane(sessionName, 20);
				const afterLength = afterOutput.length;

				// Check for signs of Claude processing the prompt
				const lengthIncrease = afterLength - beforeLength;
				const hasPromptInOutput = afterOutput.includes(prompt.substring(0, 100)); // Check first 100 chars
				const hasProcessingIndicators = /thinking|processing|analyzing|registering/i.test(
					afterOutput
				);

				if (lengthIncrease > 50 || hasProcessingIndicators || !hasPromptInOutput) {
					// Prompt appears to have been processed (content changed significantly)
					this.logger.debug(
						'Prompt delivery verified - Claude appears to be processing',
						{
							sessionName,
							attempt,
							lengthIncrease,
							hasProcessingIndicators,
						}
					);
					return true;
				}

				// If prompt is still visible and no processing detected, retry
				this.logger.warn('Prompt delivery may have failed - retrying', {
					sessionName,
					attempt,
					lengthIncrease,
					hasPromptInOutput,
					beforeLength,
					afterLength,
				});

				// Add longer delay before retry
				if (attempt < maxAttempts) {
					await new Promise((resolve) => setTimeout(resolve, 1000));
				}
			} catch (error) {
				this.logger.error('Error during robust prompt delivery', {
					sessionName,
					attempt,
					error: error instanceof Error ? error.message : String(error),
				});

				if (attempt === maxAttempts) {
					return false;
				}
			}
		}

		this.logger.error('Failed to deliver prompt after all attempts', {
			sessionName,
			maxAttempts,
		});
		return false;
	}
}
